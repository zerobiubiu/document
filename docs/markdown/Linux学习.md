## 1.4

### 1、

#### Linux发展历史：

Linux操作系统的诞生、发展和成长过程始终依赖着五个重要支柱：UNIX 操作系统、MINIX 操作系统、GNU计划、POSIX 标准和Internet 网络。

1984年，Andrew S.Tanenbaum开发了用于教学的UNIX系统，命名为Mininx。

1989年，Andrew S.Tanenbaum将Minix系统运行于x86的PC平台。

1990年，芬兰赫尔辛基大学学生Linux Torvalds首次接触Minix系统。

1991年，Linux Torvalds开始在Minix上编写各种驱动程序等操作系统内核组件。

1991年年底，Linux Torvalds公开了Linux内核源码0.02版，此版本仅仅是部分代码。

1993年，Linux 1.0版本发行，Linux转向GPL版本协议。

1994年，Linux的第一个商业发行版Slackware问世。

1996年，美国国家标准技术局的计算机系统实验室确认Linux版本1.2.13符合POSIX标准。

1999年，Linux的简体中文发行版问世。

2000年以后，Linux系统日趋成熟，涌现出大量基于Linux服务器平台的应用，并且广泛应用于基于ARM技术的嵌入式系统中。

#### 代表性的Linux发行版：

1、Red Hat Linux

2、Ubuntu Linux

3、SuSE Linux

4、Gentoo Linux

5、CentOS Linux

6、Fedora Core Linux

### 2、

#### GNU的概念：

##### 一、GNU的意思

GNU的全称：GNU is not unix，意思是：GNU 不是 unix

问：为什么这样取名？

答：为了打造一个不是unix又类unix的系统

##### 二、GNU的历程

GNU计划是由Richard Stallman 在1984年公开发起的，目标是建立一套完全自由的和可移植的类Unix操作系统。
GNU类Unix操作系统是一系列应用程序，系统库和开发工具构成的软件集合，例如：Emas编辑软件，gcc编译软件，bash命令解释程序和编程语言。


GNU操作系统自己的内核至今仍在开发中，离实际应用还有一定的距离，所以这个系统并没有流行起来。

现在GNU系统的内核通常使用linux的内核，加上GNU的一些组件，形成了一个类unix的系统。

1991年Linux内核发布的时候，GNU项目已经完成了除系统内核以外的各种必备软件开发。Linus Torvalds和其他开发人员一起把GNU项目的一些组件使用到了Linux系统上，例如：Emas编辑软件，gcc编译软件，bash命令解释程序至今都是Linux很重要的基础软件。

#### GPL的概念：

GPL，是GNU General Public License的缩写，是GNU通用公共授权非正式的中文翻译。它并非由自由软件基金会所发表，亦非使用GNU通用公共授权的软件的法定发布条款─只有GNU通用公共授权英文原文的版本始具有此等效力。

### 3、

#### 开源的软件：

数据库：MySql

操作系统：Linux

开发环境Eclipse

Web服务器：Apache和Nginx

Spring框架以及开源应用服务器：Jboss

开源浏览器：火狐Firefox，



### 4、

#### 比较流行的Liunx版本及特点：

##### 1.Red Hat Enterprise Linux：一个强大的服务器操作系统，拥有企业级的支持系统。

　　Red Hat Enterprise Linux支持所有领先的硬件架构平台(具有跨平台的兼容性)，并支撑10年以上升级和技术支持的生命周期。如果你认为升级、安全和支持非常重要，那么RedHat是最适合你的Linux发行版。RedHat拥有强大的资源管理系统，稳定的应用开发，集成的虚拟化操作(KVM)，企业级的管理性能。RedHat是一个商业的操作系统，所以你必须支付一定的费用给RedHat基金。如需要了解更多关于功能特性的详细信息，你可以看这本PDF书籍。

##### 2.Cent OS：一个为专家级用户制定的操作平台

　　Cent OS是一个社区企业级操作系统，其基础的架构与RedHat基本相同，只是license与RedHat不一样。Cent OS是一个免费且开源的发行版。如果你需要一个免费企业级的服务器版本，同时不需要技术支持，那么Cent OS对你来说是一个更好的解决方案。Cent OS具有非常好的社区支持，并有大量丰富的文档，这就是为什么它会变得日益流行起来的原因。当RedHat发布任何更新时，Cent OS也会同步更新，一般更新能够在72小时内提供。想要获得更多的信息并下载Cent OS DVD，请点击此链接。在这之后，如果你在安装Cent OS到你系统中时需要任何帮助，你可以查看我们之前的文章一步一步安装Cent OS操作系统。

##### 3.Ubuntu：一个简单但强大的操作系统，适合初级用户

　　安装简单，极棒的桌面界面，支持多种软件，还可以运行Windows软件，是初级用户的最佳选择。Ubuntu在互联网上有一个庞大的社区。在文档区，你可以找到各种问题和解决方案。Ubuntu是一个基于Debian发行版的系统，它既有桌面版也有服务器版。你可以使用Windows的安装方法来安装Ubuntu。Ubuntu的一个最好的特性是：你在其它操作系统中完成的事情，你能够在Ubuntu中用更快、更安全的方式完成。Ubuntu充满了各种免费的软件，你可以很容易地进行你的日常工作，例如创建文件，编辑图片，播放音乐和视频，用最流行的浏览器(Mozilla, Chrome)浏览互联网等。同时，它还提供2GB的在线存储空间来存储你的重要文件、图片和视频等。Ubuntu有一个简易的安装过程，它也支持用CD/DVD启动系统，从而不会打断你当前的系统。如果想要下载Ubuntu，可以点击此链接。安装后，如果你需要任何帮助，你可以查看我们以前的文章一步一步安装Ubuntu。

##### 4.SUSE Linux Enterprise Desktop：一个很好的面向桌面的操作系统

　　SUSE Linux Enterprise桌面系统是一个非常好的桌面操作系统，它拥有其它付费操作系统的所有功能。使用SUSE Linux Enterprise桌面系统，你可以将你的整体成本减少90%。它基于开源平台，安全、稳定，并且由Novel提供企业级的系统支持。SUSE Linux Enterprise桌面系统是目前最流行的可交互操作系统，它是为与Windows，UNIX，MAC和其它操作系统交互共存而设计。它支持各类文件格式，如MS Office格式，音频/视频格式等。目前SUSE团队为所有用户提供60天的试用期，你可以下载它来进行测试，看它是否真的适合你。有关详细功能信息和下载方法，你可以去这个网站查询。

##### 5.Back Track：安全专家的最佳选择

　　对于安全相关的测试，Back Track是最佳选择。它具有非常多的内置工具和插件，可以用来测试网站和网络安全。Back Track是一个基于Debian的操作系统，它能提供一种渗透测试的方法模型，这种方法能够帮助安全专家在遇到黑客攻击时，能够提供一种原生环境的估计能力。有些时候我们会问，我被感染了吗?要得到答案，首先你要测试你的系统是否有任何安全漏洞，这时，Back Track就可以成为你的好帮手。Back Track有很好的社区支持，社区中包含很多指南。想获得更多的信息，你可以访问Back Track官方网站。

## 2.4

### 1、

#### 32位和64位操作系统有什么区别：

1、支持的内存不同
32位系统支持的内存最大是4G，与此同时，64位系统则支持4G、 8G、 16G、32G、 64G 、128G 以及256G的内存，可见，64位系统支持的系统内存有更多的选择。更让人惊奇的是，64位系统在理论上，只要有足够的内存条，就可以无限支持。
2、支持的处理器不同
64位系统自然支持64位以及32位的处理器，同时，32位系统不能支持64位处理器。
3、支持的软件不同
32位支持基于32位的软件，由于自身的限制，不能支持64位软件，64位则可以支持32位以及64位的软件，并与各种软件都能够兼容，64位软件在将来的软件应用中，具有更高的优势，因为很多adobe公司的软件都只支持64位。
4、处理数据的能力
64位的系统对于数据的处理能力要比32位快1倍。
5、系统体积大小
64位系统都比32位系统大。
32位和64位的区别主要体现在支持的内存、处理器、软件、处理数据的能力以及体积的大小等方面的不同，大家要根据自身电脑的参数，来决定安装哪一个。

#### 如何查看Linux是32位还是64位的：

在linux终端输入getconf LONG_BIT命令，多少位返回多少数

在linux终端输入uname -a命令，返回内容带有X86_64就是64位，i386是32位

在linux终端输入file /sbin/init 或者 file /bin/ls命令， 可以通过命令结果中的64-bit或者32-bit来判断该机器是64位还是32位

### 2、

#### swap分区的作用是什么：

SWAP就是LINUX下的虚拟内存分区,它的作用是在物理内存使用完之后,将磁盘空间(也就是SWAP分区)虚拟成内存来使度用.

#### 如何决定swap分区大小：

 一般情况，在安装系统的时候很难决定多大的交换空间，往往需要根据服务器实际负载、运行情况、以及未来可能应用来综合考虑 swap 分区的大小，所以这里参考推荐最小 swap 大小更实际一些：

4GB 或 4GB 以下内存的系统，最小需要 2GB 交换空间；
大于 4GB 而小于 16GB 内存的系统，最小需要 4GB 交换空间；
大于 16GB 而小于 64GB 内存的系统，最小需要 8GB 交换空间；
大于 64GB 而小于 256GB 内存的系统，最小需要 16GB 交换空间；

### 3、

#### bootloader的概念和作用：

Bootloader是嵌入式系统的引导加载程序，它是系统上电后运行的第一段程序，其作用类似于PC机上的BIOS。 在完成对系统的初始化任务之后，它会将非易失性存储器(通常是F1ash或DOC等)中的Linux内核拷贝到RAM中去，然后跳转到内核的第一条指 令处继续执行，从而启动Linux 内核。由此可见，bootloader和Linux内核有着密不可分的联系，要想清楚的了解Linux内核的启动过程，我们必须先得认识bootloader 的执行过程，这样才能对嵌入式系统的整个启过程有清晰的掌握。

#### grup的概念和作用：

GNU GRUB（GRand Unified Bootloader简称“GRUB”）是一个来自GNU项目的多操作系统启动程序。GRUB是多启动规范的实现，它允许用户可以在计算机内同时拥有多个操作系统，并在计算机启动时选择希望运行的操作系统。GRUB可用于选择操作系统分区上的不同内核，也可用于向这些内核传递启动参数。

### 4、

#### 如何在装系统时给grub设置密码：

（1）title前
首先能进入系统，修改/etc/grub.conf，在title前加“password XXXX”。再次启动就需要按p输入grub密码。
（2）title后
同理，修改grub.conf在title后加password ，这样启动时会输入密码，连续按三次e容易在grub菜单暴露密码。用grub-md5-crypt加密后e799bee5baa6e4b893e5b19e31333363396430会产生密文，复制加密字符串到grub.conf中root（hd0,0）下，写入“password --md5 密文”。
给grub加密码分两种
设置加密的密码（密文） 用grub命令生成密码的密文 ，输入密码之后就会生成该密码的密文
\#grub-crypt --md5
Password:123
Retypepassword: 123
$1$K5VbYDgm$n./HW30DDkTt5rzAIOHBe/
grub.conf里面配置 加下面一行 就可以了，启动的时候进入grub菜单需要按p输入密码才能修改
password--md5 $1$47mDgrVd$ICuZyXfD0ooo/Jy0AMxFL0
不同的加密方式，$1头部都会不一样
设置未加密的密码（明文）
grub.conf里面配置 加下面一行
password=123456》



## 命令：

ip addr	查看IP地址

systemctl restart network.service	重启网络服务

yum groupinstall -y "GNOME Desktop"	Centos图形界面安装

### Centos8防火墙端口

```shell
查看防火墙某个端口是否开放
# firewall-cmd --query-port=3306/tcp

开放防火墙端口3306
# firewall-cmd --zone=public --add-port=3306/tcp --permanent

查看防火墙状态
# systemctl status firewalld

关闭防火墙
# systemctl stop firewalld

打开防火墙
# systemctl start firewalld

开放一段端口
# firewall-cmd --zone=public --add-port=40000-45000/tcp --permanent

查看开放的端口列表
# firewall-cmd --zone=public --list-ports
```

### cat

```shell
# cat 命令连接文件并打印到标准输出设备上，cat经常用来显示文件的内容，类似于下的type命令。
-n或-number：有1开始对所有输出的行数编号；
-b或--number-nonblank：和-n相似，只不过对于空白行不编号；
-s或--squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行；
-A：显示不可打印字符，行尾显示“$”；
-e：等价于"-vE"选项；
-t：等价于"-vT"选项；

设ml和m2是当前目录下的两个文件

# cat m1 （在屏幕上显示文件ml的内容）
# cat m1 m2 （同时显示文件ml和m2的内容）
# cat m1 m2 > file （将文件ml和m2合并后放入文件file中）
```

### cd

```shell
# cd 绝对目录或相对目录		进入绝对目录或相对目录
# cd    进入用户主目录；
# cd ~  进入用户主目录；
# cd -  返回进入此目录之前所在的目录；
# cd ..  返回上级目录（若当前目录为“/“，则执行完后还在“/"；".."为上级目录的意思）；
# cd ../..  返回上两级目录；
# cd !$  把上个命令的参数作为cd参数使用。
```

### chattr

```shell
# chattr命令用来改变文件属性。这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式：
a：让文件或目录仅供附加用途；
b：不更新文件或目录的最后存取时间；
c：将文件或目录压缩后存放；
d：将文件或目录排除在倾倒操作之外；
i：不得任意更动文件或目录；
s：保密性删除文件或目录；
S：即时更新文件或目录；
u：预防意外删除。

-R：递归处理，将指令目录下的所有文件及子目录一并处理；
-v<版本编号>：设置文件或目录版本；
-V：显示指令执行过程；
+<属性>：开启文件或目录的该项属性；
-<属性>：关闭文件或目录的该项属性；
=<属性>：指定文件或目录的该项属性。

用chattr命令防止系统中某个关键文件被修改：
# chattr +i /etc/fstab
然后试一下rm、mv、rename等命令操作于该文件，都是得到Operation not permitted的结果。

让某个文件只能往里面追加内容，不能删除，一些日志文件适用于这种操作：
# chattr +a /data1/user_act.log
```

### chfn

```shell
# chfn	命令用来改变finger命令显示的信息。这些信息都存放在/etc目录里的passwd文件里。若不指定任何选项，则chfn命令会进入问答式界面。

-f<真实姓名>或--full-name<真实姓名>：设置真实姓名；
-h<家中电话>或--home-phone<家中电话>：设置家中的电话号码；
-o<办公地址>或--office<办公地址>：设置办公室的地址；
-p<办公电话>或--office-phone<办公电话>：设置办公室的电话号码；
-u或--help：在线帮助；
-v或-version：显示版本信息。

范例1，改变finger信息：

[root@localhost Desktop]# chfn
Changing finger information for root.
Name [root]: jack
Office []: hn
Office Phone []: 888888
Home Phone []: 9999999
 
Finger information changed.


范例2，改变账号真实姓名：

[root@localhost Desktop]# chfn -f jack
Changing finger information for root.
Finger information changed.


范例3：

shell>> chfn
Changing finger information for user
Password: [del]
Name[]:linuxde ### 提供 finger 时的资料
Office[]:NCCU
Office Phone[]: [del]
Home Phone[]: [del]
```

### chgrp

```shell
# chgrp 命令用来改变文件或目录所属的用户组。该命令用来改变指定文件所属的用户组。其中，组名可以是用户组的id，也可以是用户组的组名。文件名可以 是由空格分开的要改变属组的文件列表，也可以是由通配符描述的文件集合。如果用户不是该文件的文件主或超级用户(root)，则不能改变该文件的组。
-c或——changes：效果类似“-v”参数，但仅回报更改的部分；
-f或--quiet或——silent：不显示错误信息；
-h或--no-dereference：只对符号连接的文件作修改，而不是该其他任何相关文件；
-R或——recursive：递归处理，将指令目录下的所有文件及子目录一并处理；
-v或——verbose：显示指令执行过程；
--reference=<参考文件或目录>：把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同；

# chgrp tdt test1				将test1文件所属组改为tdt
# chgrp -R mengxin /usr/meng	将/usr/meng及其子目录下的所有文件的用户组改为mengxin
```

### chmod

```shell
# chmod 命令用来变更文件或目录的权限。在UNIX系统家族里，文件或目录权限的控制分别以读取、写入、执行3种一般权限来区分，另有3种特殊权限可供运用。用户可以使用chmod指令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件。

限范围的表示法如下：
u User，即文件或目录的拥有者；
g Group，即文件或目录的所属群组；
o Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围；
a All，即全部的用户，包含拥有者，所属群组以及其他用户；
r 读取权限，数字代号为“4”;
w 写入权限，数字代号为“2”；
x 执行或切换权限，数字代号为“1”；
- 不具任何权限，数字代号为“0”；
s 特殊功能说明：变更文件或目录的权限。

-c或——changes：效果类似“-v”参数，但仅回报更改的部分；
-f或--quiet或——silent：不显示错误信息；
-R或——recursive：递归处理，将指令目录下的所有文件及子目录一并处理；
-v或——verbose：显示指令执行过程；
--reference=<参考文件或目录>：把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同；
<权限范围>+<权限设置>：开启权限范围的文件或目录的该选项权限设置；
<权限范围>-<权限设置>：关闭权限范围的文件或目录的该选项权限设置；
<权限范围>=<权限设置>：指定权限范围的文件或目录的该选项权限设置；

# chmod u+x,g+w f01　　//为文件f01设置自己可以执行，组员可以写入的权限
# chmod u=rwx,g=rw,o=r f01
# chmod 764 f01
# chmod a+x f01　　//对文件f01的u,g,o都设置可执行属性
# chown user:market f01　　//把文件f01给uesr，添加到market组
```

### chown

```shell
# chown 命令改变某个文件或目录的所有者和所属的组，该命令可以向某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组。用户可以是用户或者是用户D，用户组可以是组名或组id。文件名可以使由空格分开的文件列表，在文件名中可以包含通配符。
-c或——changes：效果类似“-v”参数，但仅回报更改的部分；
-f或--quite或——silent：不显示错误信息；
-h或--no-dereference：只对符号连接的文件作修改，而不更改其他任何相关文件；
-R或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；
-v或——version：显示指令执行过程；
--dereference：效果和“-h”参数相同；
--help：在线帮助；
--reference=<参考文件或目录>：把指定文件或目录的拥有者与所属群组全部设成和参考文件或目录的拥有者与所属群组相同；
--version：显示版本信息。

# chown tdt1 test1				将test1文件主改为tdt1
# chown -R liu /usr/meng	将目录/usr/meng及其下面的所有文件、子目录的文件主改成 liu
```

### cp

```shell
# cp命令用来将一个或多个源文件或者目录复制到指定的目的文件或目录。它可以将单个源文件复制成一个指定文件名的具体的文件或一个已经存在的目录下。cp命令还支持同时复制多个文件，当一次复制多个文件时，目标文件参数必须是一个已经存在的目录，否则将出现错误。

-a：此参数的效果和同时指定"-dpR"参数相同；
-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；
-f：强行复制文件或目录，不论目标文件或目录是否已存在；
-i：覆盖既有文件之前先询问用户；
-l：对源文件建立硬连接，而非复制文件；
-p：保留源文件或目录的属性；
-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；
-s：对源文件建立符号连接，而非复制文件；
-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；
-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；
-b：覆盖已存在的文件目标前将目标文件备份；
-v：详细显示命令执行的操作。

所有目标文件指定的目录必须是己经存在的，cp命令不能创建目录。如果没有文件复制的权限，则系统会显示出错信息。
# cp file /usr/men/tmp/file1       将文件file复制到目录/usr/men/tmp下，并改名为file1
# cp -i /usr/men m*.c /usr/z       h交互式地将目录/usr/men中的以m打头的所有.c文件复制到目录/usr/zh中

我们在Linux下使用cp命令复制文件时候，有时候会需要覆盖一些同名文件，覆盖文件的时候都会有提示：需要不停的按Y来确定执行覆盖。文件数量不多还好，但是要是几百个估计按Y都要吐血了，于是折腾来半天总结了一个方法：
# cp aaa/* /bbb          复制目录aaa下所有到/bbb目录下，这时如果/bbb目录下有和aaa同名的文件，需要按Y来确认并且会略过aaa目录下的子目录。
# cp -r aaa/* /bbb       这次依然需要按Y来确认操作，但是没有忽略子目录。
# cp -r -a aaa/* /bbb    依然需要按Y来确认操作，并且把aaa目录以及子目录和文件属性也传递到了/bbb。
# \cp -r -a aaa/* /bbb   成功，没有提示按Y、传递了目录属性、没有略过目录。
```

### df

```shell
# df	命令用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。

-a或--all：包含全部的文件系统；
--block-size=<区块大小>：以指定的区块大小来显示区块数目；
-h或--human-readable：以可读性较高的方式来显示信息；
-H或--si：与-h参数相同，但在计算时是以1000 Bytes为换算单位而非1024 Bytes；
-i或--inodes：显示inode的信息；
-k或--kilobytes：指定区块大小为1024字节；
-l或--local：仅显示本地端的文件系统；
-m或--megabytes：指定区块大小为1048576字节；
--no-sync：在取得磁盘使用信息前，不要执行sync指令，此为预设值；
-P或--portability：使用POSIX的输出格式；
--sync：在取得磁盘使用信息前，先执行sync指令；
-t<文件系统类型>或--type=<文件系统类型>：仅显示指定文件系统类型的磁盘信息；
-T或--print-type：显示文件系统的类型；
-x<文件系统类型>或--exclude-type=<文件系统类型>：不要显示指定文件系统类型的磁盘信息；
--help：显示帮助；
--version：显示版本信息。


查看系统磁盘设备，默认是KB为单位：
[root@LinServ-1 ~]# df
文件系统               1K-块        已用     可用 已用% 挂载点
/dev/sda2            146294492  28244432 110498708  21% /
/dev/sda1              1019208     62360    904240   7% /boot
tmpfs                  1032204         0   1032204   0% /dev/shm
/dev/sdb1            2884284108 218826068 2518944764   8% /data1


使用-h选项以KB以上的单位来显示，可读性高：
[root@LinServ-1 ~]# df -h
文件系统              容量  已用 可用 已用% 挂载点
/dev/sda2             140G   27G  106G  21% /
/dev/sda1             996M   61M  884M   7% /boot
tmpfs                1009M     0 1009M   0% /dev/shm
/dev/sdb1             2.7T  209G  2.4T   8% /data1


查看全部文件系统：
[root@LinServ-1 ~]# df -a
文件系统               1K-块        已用     可用 已用% 挂载点
/dev/sda2            146294492  28244432 110498708  21% /
proc                         0         0         0   -  /proc
sysfs                        0         0         0   -  /sys
devpts                       0         0         0   -  /dev/pts
/dev/sda1              1019208     62360    904240   7% /boot
tmpfs                  1032204         0   1032204   0% /dev/shm
/dev/sdb1            2884284108 218826068 2518944764   8% /data1
none                         0         0         0   -  /proc/sys/fs/binfmt_misc
```

### dhclient

```shell
# dhclient 命令使用动态主机配置协议动态的配置网络接口的网络参数。
0：指定dhcp客户端监听的端口号；
-d：总是以前台方式运行程序；
-q：安静模式，不打印任何错误的提示信息；
-r：释放ip地址。

# dhclient -r     释放IP
# dhclient        获取IP
```

### du

```shell
# du	命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的。

-a或-all 显示目录中个别文件的大小。
-b或-bytes 显示目录或文件大小时，以byte为单位。
-c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。
-k或--kilobytes 以KB(1024bytes)为单位输出。
-m或--megabytes 以MB为单位输出。
-s或--summarize 仅显示总计，只列出最后加总的值。
-h或--human-readable 以K，M，G为单位，提高信息的可读性。
-x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。
-L<符号链接>或--dereference<符号链接> 显示选项中所指定符号链接的源文件大小。
-S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。
-X<文件>或--exclude-from=<文件> 在<文件>指定目录或文件。
--exclude=<目录或文件> 略过指定的目录或文件。
-D或--dereference-args 显示指定符号链接的源文件大小。
-H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。
-l或--count-links 重复计算硬件链接的文件。


显示目录或者文件所占空间：
[root@localhost test]# du
608 ./test6
308 ./test4
4 ./scf/lib
4 ./scf/service/deploy/product
4 ./scf/service/deploy/info
12 ./scf/service/deploy
16 ./scf/service
4 ./scf/doc
4 ./scf/bin
32 ./scf
8 ./test3
1288 .


只显示当前目录下面的子目录的目录大小和当前目录的总的大小，最下面的1288为当前目录的总大小显示指定文件所占空间：
[root@localhost test]# du log2012.log
300 log2012.log


查看指定目录的所占空间：
[root@localhost test]# du scf
4 scf/lib
4 scf/service/deploy/product
4 scf/service/deploy/info
12 scf/service/deploy
16 scf/service
4 scf/doc
4 scf/bin
32 scf


显示多个文件所占空间：
[root@localhost test]# du log30.tar.gz log31.tar.gz
4 log30.tar.gz
4 log31.tar.gz


只显示总和的大小:
[root@localhost test]# du -s
1288 .

[root@localhost test]# du -s scf
32 scf

[root@localhost test]# cd ..
[root@localhost soft]# du -s test
1288 test
```

### fdisk

### find

```shell
# find 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。
-amin<分钟>：查找在指定时间曾被存取过的文件或目录，单位以分钟计算；
-anewer<参考文件或目录>：查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录；
-atime<24小时数>：查找在指定时间曾被存取过的文件或目录，单位以24小时计算；
-cmin<分钟>：查找在指定时间之时被更改过的文件或目录；
-cnewer<参考文件或目录>查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；
-ctime<24小时数>：查找在指定时间之时被更改的文件或目录，单位以24小时计算；
-daystart：从本日开始计算时间；
-depth：从指定目录下最深层的子目录开始查找；
-empty：寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录；
-exec<执行指令>：假设find指令的回传值为True，就执行该指令；
-false：将find指令的回传值皆设为False；
-fls<列表文件>：此参数的效果和指定“-ls”参数类似，但会把结果保存为指定的列表文件；
-follow：排除符号连接；
-fprint<列表文件>：此参数的效果和指定“-print”参数类似，但会把结果保存成指定的列表文件；
-fprint0<列表文件>：此参数的效果和指定“-print0”参数类似，但会把结果保存成指定的列表文件；
-fprintf<列表文件><输出格式>：此参数的效果和指定“-printf”参数类似，但会把结果保存成指定的列表文件；
-fstype<文件系统类型>：只寻找该文件系统类型下的文件或目录；
-gid<群组识别码>：查找符合指定之群组识别码的文件或目录；
-group<群组名称>：查找符合指定之群组名称的文件或目录；
-help或——help：在线帮助；
-ilname<范本样式>：此参数的效果和指定“-lname”参数类似，但忽略字符大小写的差别；
-iname<范本样式>：此参数的效果和指定“-name”参数类似，但忽略字符大小写的差别；
-inum<inode编号>：查找符合指定的inode编号的文件或目录；
-ipath<范本样式>：此参数的效果和指定“-path”参数类似，但忽略字符大小写的差别；
-iregex<范本样式>：此参数的效果和指定“-regexe”参数类似，但忽略字符大小写的差别；
-links<连接数目>：查找符合指定的硬连接数目的文件或目录；
-iname<范本样式>：指定字符串作为寻找符号连接的范本样式；
-ls：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出；
-maxdepth<目录层级>：设置最大目录层级；
-mindepth<目录层级>：设置最小目录层级；
-mmin<分钟>：查找在指定时间曾被更改过的文件或目录，单位以分钟计算；
-mount：此参数的效果和指定“-xdev”相同；
-mtime<24小时数>：查找在指定时间曾被更改过的文件或目录，单位以24小时计算；
-name<范本样式>：指定字符串作为寻找文件或目录的范本样式；
-newer<参考文件或目录>：查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；
-nogroup：找出不属于本地主机群组识别码的文件或目录；
-noleaf：不去考虑目录至少需拥有两个硬连接存在；
-nouser：找出不属于本地主机用户识别码的文件或目录；
-ok<执行指令>：此参数的效果和指定“-exec”类似，但在执行指令之前会先询问用户，若回答“y”或“Y”，则放弃执行命令；
-path<范本样式>：指定字符串作为寻找目录的范本样式；
-perm<权限数值>：查找符合指定的权限数值的文件或目录；
-print：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串；
-print0：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行；
-printf<输出格式>：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式可以自行指定；
-prune：不寻找字符串作为寻找文件或目录的范本样式;
-regex<范本样式>：指定字符串作为寻找文件或目录的范本样式；
-size<文件大小>：查找符合指定的文件大小的文件；
-true：将find指令的回传值皆设为True；
-type<文件类型>：只寻找符合指定的文件类型的文件；
-uid<用户识别码>：查找符合指定的用户识别码的文件或目录；
-used<日数>：查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算；
-user<拥有者名称>：查找符和指定的拥有者名称的文件或目录；
-version或——version：显示版本信息；
-xdev：将范围局限在先行的文件系统中；
-xtype<文件类型>：此参数的效果和指定“-type”参数类似，差别在于它针对符号连接检查。

					根据文件或者正则表达式进行匹配:
# find .	列出当前目录及子目录下所有文件和文件夹
# find /home -name "*.txt"	在/home目录下查找以.txt结尾的文件名
同上，但忽略大小写:
# find /home -iname "*.txt"

当前目录及子目录下查找所有以.txt和.pdf结尾的文件
# find . \( -name "*.txt" -o -name "*.pdf" \)
或	# find . -name "*.txt" -o -name "*.pdf"

# find /usr/ -path "*local*"	匹配文件路径或者文件
# find . -regex ".*\(\.txt\|\.pdf\)$"	基于正则表达式匹配文件路径
同上，但忽略大小写
# find . -iregex ".*\(\.txt\|\.pdf\)$"

							否定参数:
# find /home ! -name "*.txt"	找出/home下不是以.txt结尾的文件

						根据文件类型进行搜索:
# find . -type 类型参数
类型参数列表：
f 普通文件
l 符号连接
d 目录
c 字符设备
b 块设备
s 套接字
p Fifo

							基于目录深度搜索:
# find . -maxdepth 3 -type f		向下最大深度限制为3
# find . -mindepth 2 -type f		搜索出深度距离当前目录至少2个子目录的所有文件

						根据文件时间戳进行搜索:
# find . -type f 时间戳
UNIX/Linux文件系统每个文件都有三种时间戳：
访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间。
修改时间（-mtime/天，-mmin/分钟）：文件最后一次修改时间。
变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。

# find . -type f -atime -7			搜索最近七天内被访问过的所有文件
# find . -type f -atime 7			搜索恰好在七天前被访问过的所有文件
# find . -type f -atime +7			搜索超过七天内被访问过的所有文件
# find . -type f -amin +10			搜索访问时间超过10分钟的所有文件
# find . -type f -newer file.log		找出比file.log修改时间更长的所有文件

						根据文件大小进行匹配:
# find . -type f -size 文件大小单元
文件大小单元：
b —— 块（512字节）
c —— 字节
w —— 字（2字节）
k —— 千字节
M —— 兆字节
G —— 吉字节

# find . -type f -size +10k		搜索大于10KB的文件
# find . -type f -size -10k		搜索小于10KB的文件
# find . -type f -size 10k		搜索等于10KB的文件

							删除匹配文件:
# find . -type f -name "*.txt" -delete		删除当前目录下所有.txt文件

					根据文件权限/所有权进行匹配:
# find . -type f -perm 777		当前目录下搜索出权限为777的文件
# find . -type f -name "*.php" ! -perm 644		找出当前目录下权限不是644的php文件
# find . -type f -user tom		找出当前目录用户tom拥有的所有文件
# find . -type f -group sunk	找出当前目录用户组sunk拥有的所有文件

				借助-exec选项与其他命令结合使用:
找出当前目录下所有root的文件，并把所有权更改为用户tom
# find .-type f -user root -exec chown tom {} \;
上例中，{} 用于与-exec选项结合使用来匹配所有文件，然后会被替换为相应的文件名。

找出自己家目录下所有的.txt文件并删除
# find $HOME/. -name "*.txt" -ok rm {} \;
上例中，-ok和-exec行为一样，不过它会给出提示，是否执行相应的操作。

查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中
# find . -type f -name "*.txt" -exec cat {} \;> all.txt

将30天前的.log文件移动到old目录中
# find . -type f -mtime +30 -name "*.log" -exec cp {} old \;

找出当前目录下所有.txt文件并以“File:文件名”的形式打印出来
# find . -type f -name "*.txt" -exec printf "File: %s\n" {} \;

因为单行命令中-exec参数中无法使用多个命令，以下方法可以实现在-exec之后接受多条命令
# -exec ./text.sh {} \;

						搜索但跳出指定的目录:
查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk
# find . -path "./sk" -prune -o -name "*.txt" -print
				
						find其他技巧收集:
要列出所有长度为零的文件
# find . -empty
```

### groupadd

```shell
# groupadd	命令用于创建一个新的工作组，新工作组的信息将被添加到系统文件中。

-g：指定新建工作组的id；
-r：创建系统工作组，系统工作组的组ID小于500；
-K：覆盖配置文件“/ect/login.defs”；
-o：允许添加组ID号不唯一的工作组。

建立一个新组，并设置组ID加入系统：
# groupadd -g 344 linuxde
此时在/etc/passwd文件中产生一个组ID（GID）是344的项目。
```

### groupdel

```shell
# groupdel 命令用于删除指定的工作组，本命令要修改的系统文件包括/ect/group和/ect/gshadow。若该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。

# groupadd damon  //创建damon工作组
# groupdel damon  //删除这个工作组
```

### halt

```shell
# halt             ### 停止机器 
# halt -p          ### 关闭机器 
# halt --reboot    ### 重启机器 
```

### head

```shell
# head 命令用于显示文件的开头的内容。在默认情况下，head命令显示文件的头10行内容。
-n<数字>：指定显示头部内容的行数；
-c<字符数>：指定显示头部内容的字符数；
-v：总是显示文件名的头信息；
-q：不显示文件名的头信息。
```

### ifconfig

```shell
# ifconfig 命令被用于配置和显示Linux内核中网络接口的网络参数。用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。
add<地址>：设置网络设备IPv6的ip地址；
del<地址>：删除网络设备IPv6的IP地址；
down：关闭指定的网络设备；
<hw<网络设备类型><硬件地址>：设置网络设备的类型与硬件地址；
io_addr<I/O地址>：设置网络设备的I/O地址；
irq<IRQ地址>：设置网络设备的IRQ；
media<网络媒介类型>：设置网络设备的媒介类型；
mem_start<内存地址>：设置网络设备在主内存所占用的起始地址；
metric<数目>：指定在计算数据包的转送次数时，所要加上的数目；
mtu<字节>：设置网络设备的MTU；
netmask<子网掩码>：设置网络设备的子网掩码；
tunnel<地址>：建立IPv4与IPv6之间的隧道通信地址；
up：启动指定的网络设备；
-broadcast<地址>：将要送往指定地址的数据包当成广播数据包来处理；
-pointopoint<地址>：与指定地址的网络设备建立直接连线，此模式具有保密功能；
-promisc：关闭或启动指定网络设备的promiscuous模式；
IP地址：指定网络设备的IP地址；
网络设备：指定网络设备的名称。

						显示网络设备信息（激活状态的）：
# ifconfig
eth0      Link encap:Ethernet  HWaddr 00:16:3E:00:1E:51  
          inet addr:10.160.7.81  Bcast:10.160.15.255  Mask:255.255.240.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:61430830 errors:0 dropped:0 overruns:0 frame:0
          TX packets:88534 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:3607197869 (3.3 GiB)  TX bytes:6115042 (5.8 MiB)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:56103 errors:0 dropped:0 overruns:0 frame:0
          TX packets:56103 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:5079451 (4.8 MiB)  TX bytes:5079451 (4.8 MiB)
说明：

	eth0表示第一块网卡，其中HWaddr表示网卡的物理地址，可以看到目前这个网卡的物理地址(MAC地址）是00:16:3E:00:1E:51。
	inet addr用来表示网卡的IP地址，此网卡的IP地址是10.160.7.81，广播地址Bcast:10.160.15.255，掩码地址Mask:255.255.240.0。
	lo是表示主机的回环地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 httpd服务器的指定到回环地址，在浏览器输入127.0.0.1就能看到你所架WEB网站了。但只是您能看得到，局域网的其它主机或用户无从知道。

第一行：连接类型：Ethernet（以太网）HWaddr（硬件mac地址）。
第二行：网卡的IP地址、子网、掩码。
第三行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播）MTU:1500（最大传输单元）：1500字节。
第四、五行：接收、发送数据包情况统计。
第七行：接收、发送数据字节数统计信息。

启动关闭指定网卡：
# ifconfig eth0 up			启动网卡eth0
# ifconfig eth0 down		为关闭网卡eth0
ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。

为网卡配置和删除IPv6地址：
# ifconfig eth0 add 33ffe:3240:800:1005::2/64    	为网卡eth0配置IPv6地址
# ifconfig eth0 del 33ffe:3240:800:1005::2/64    	为网卡eth0删除IPv6地址

用ifconfig修改MAC地址：
ifconfig eth0 hw ether 00:AA:BB:CC:dd:EE

配置IP地址：
# ifconfig eth0 192.168.2.10
# ifconfig eth0 192.168.2.10 netmask 255.255.255.0
# ifconfig eth0 192.168.2.10 netmask 255.255.255.0 broadcast 192.168.2.255

启用和关闭arp协议：
# ifconfig eth0 arp    	开启网卡eth0 的arp协议
# ifconfig eth0 -arp   	关闭网卡eth0 的arp协议

设置最大传输单元：
# ifconfig eth0 mtu 1500    	设置能通过的最大数据包大小为 1500 bytes
```

### less

```shell
# less 命令的作用与more十分相似，都可以用来浏览文字档案的内容，不同的是less命令允许用户向前或向后浏览文件，而more命令只能向前浏览。用less命令显示文件时，用PageUp键向上翻页，用PageDown键向下翻页。要退出less程序，应按Q键。
-e：文件内容显示完毕后，自动退出；
-f：强制显示文件；
-g：不加亮显示搜索到的所有关键词，仅显示当前显示的关键字，以提高显示速度；
-l：搜索时忽略大小写的差异；
-N：每一行行首显示行号；
-s：将连续多个空行压缩成一行显示；
-S：在单行显示较长的内容，而不换行显示；
-x<数字>：将TAB字符显示为指定个数的空格字符。
```

### ln

```shell
# ln 命令用来为文件创件连接，连接类型分为硬连接和符号连接两种，默认的连接类型是硬连接。如果要创建符号连接必须使用"-s"选项。
-b或--backup：删除，覆盖目标文件之前的备份；
-d或-F或——directory：建立目录的硬连接；
-f或——force：强行建立文件或目录的连接，不论文件或目录是否存在；
-i或——interactive：覆盖既有文件之前先询问用户；
-n或--no-dereference：把符号连接的目的目录视为一般文件；
-s或——symbolic：对源文件建立符号连接，而非硬连接；
-S<字尾备份字符串>或--suffix=<字尾备份字符串>：用"-b"参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，预设的备份字符串是符号“~”，用户可通过“-S”参数来改变它；
-v或——verbose：显示指令执行过程；
-V<备份方式>或--version-control=<备份方式>：用“-b”参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这个字符串不仅可用“-S”参数变更，当使用“-V”参数<备份方式>指定不同备份方式时，也会产生不同字尾的备份字符串；
--help：在线帮助；
--version：显示版本信息。

将目录/usr/mengqc/mub1下的文件m2.c链接到目录/usr/liu下的文件a2.c
# cd /usr/mengqc
# ln /mub1/m2.c /usr/liu/a2.c
在执行ln命令之前，目录/usr/liu中不存在a2.c文件。执行ln之后，在/usr/liu目录中才有a2.c这一项，表明m2.c和a2.c链接起来（注意，二者在物理上是同一文件），利用ls -l命令可以看到链接数的变化。

在目录/usr/liu下建立一个符号链接文件abc，使它指向目录/usr/mengqc/mub1
# ln -s /usr/mengqc/mub1 /usr/liu/abc
执行该命令后，/usr/mengqc/mub1代表的路径将存放在名为/usr/liu/abc的文件中。
```

### init

```shell
0  停机（千万不能把initdefault 设置为0）
1  单用户模式
2  多用户，没有 NFS(和级别3相似，会停止部分服务)
3  完全多用户模式
4  没有用到
5  x11(Xwindow)
6  重新启动（千万不要把initdefault 设置为6）

# init 5	图形化界面模式
```

### lnuseradd

```shell
# useradd	命令用于Linux中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。

-c<备注>：加上备注文字。备注文字会保存在passwd的备注栏位中；
-d<登入目录>：指定用户登入时的启始目录；
-D：变更预设值；
-e<有效期限>：指定帐号的有效期限；
-f<缓冲天数>：指定在密码过期后多少天即关闭该帐号；
-g<群组>：指定用户所属的群组；
-G<群组>：指定用户所属的附加群组；
-m：自动建立用户的登入目录；
-M：不要自动建立用户的登入目录；
-n：取消建立以用户名称为名的群组；
-r：建立系统帐号；
-s<shell>：指定用户登入后所使用的shell；
-u<uid>：指定用户id。

新建用户加入组：
# useradd –g sales jack –G company,employees    //-g：加入主要组、-G：加入次要组

建立一个新用户账户，并设置ID：
# useradd caojh -u 544

需要说明的是，设定ID值时尽量要大于500，以免冲突。因为Linux安装后会建立一些特殊用户，一般0到499之间的值留给bin、mail这样的系统账号。
```

### locate

```shell
# locate命令和slocate命令都用来查找文件或目录。
locate命令其实是find -name的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库/var/lib/locatedb，这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。
-d<目录>或--database=<目录>：指定数据库所在的目录；
-u：更新slocate数据库；
--help：显示帮助；
--version：显示版本信息。

# locate /etc/sh	搜索etc目录下所有以sh开头的文件
# locate ~/m		搜索用户主目录下，所有以m开头的文件
# locate -i ~/m		搜索用户主目录下，所有以m开头的文件，并且忽略大小写
```

### ls

```shell
# ls /	根目录文件
# ls 后面不加任何选项也不跟目录名或者文件名：会列出当前目录下的文件和目录，不包含隐藏文件
# ls 后面加-a选项、不加目录名或者文件名：会列出当前目录下所有文件和目录。包含隐藏文件
# ls 后面加-l选项、不加目录名或文件名：会列出当前目录下除隐藏文件外的所有文件和目录的详细信息，包含其权限、所属主、所属组以及文件创建日期和时间
# ls 后面不加选项、只跟文件名：会列出该文件，使用时通常都是加上-l选项，用来查看该文件的详细信息
# ls 后面不加选项，只跟目录名：会列出指定目录下的文件和目录
```

### lsattr

```shell
# lsattr 命令用于查看文件的第二扩展文件系统属性。
-E：可显示设备属性的当前值，但这个当前值是从用户设备数据库中获得的，而不是从设备直接获得的。
-D：显示属性的名称，属性的默认值，描述和用户是否可以修改属性值的标志。
-R：递归的操作方式；
-V：显示指令的版本信息；
-a：列出目录中的所有文件，包括隐藏文件。
lsattr经常使用的几个选项-D，-E，-R这三个选项不可以一起使用，它们是互斥的，经常使用的还有-l,-H，使用lsattr时，必须指出具体的设备名，用-l选项指出要显示设备的逻辑名称，否则要用-c，-s，-t等选项唯一的确定某个已存在的设备。

# lsattr -E -l rmt0 -H
# lsattr -EO -l rmt0
```

### man

```shell
# man 命令是Linux下的帮助指令，通过man指令可以查看Linux中的指令帮助、配置文件帮助和编程帮助等信息。
-a：在所有的man帮助手册中搜索；
-f：等价于whatis指令，显示给定关键字的简短描述信息；
-P：指定内容时使用分页程序；
-M：指定man手册搜索的路径。

我们输入man ls，它会在最左上角显示“LS（1）”，在这里，“LS”表示手册名称，而“（1）”表示该手册位于第一节章，同样，我们输man ifconfig它会在最左上角显示“IFCONFIG（8）”。也可以这样输入命令：“man [章节号] 手册名称”。

man是按照手册的章节号的顺序进行搜索的，比如：
# man sleep
只会显示sleep命令的手册,如果想查看库函数sleep，就要输入:
# man 3 sleep
```

### mkdir

```shell
# mkdir		创建目录命令
-Z：设置安全上下文，当使用SELinux时有效；
-m<目标属性>或--mode<目标属性>建立目录的同时设置目录的权限；
-p或--parents 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录；
--version 显示版本信息。
```

### mkpasswd

```shell
# mkpasswd	用于生成密码。我们安装的Linux默认是没有这个命令的，需要安装一个expect软件包，安装命令如下：

# yum install -y expect
# mkpasswd
HXut8oy*8

-l # (密码的长度定义, 默认是 9)
-d # (数字个数, 默认是 2)
-c # (小写字符个数, 默认是 2)
-C # (大写字符个数, 默认是 2)
-s # (特殊字符个数, 默认是 1)
-v (详细。。。)
-p prog (程序设置密码, 默认是 passwd)


# mkpasswd -l 20	 #生成随机密码同时制定长度为20
mMgfg7bfH~5irgacvqna

# mkpasswd 		 #生成默认长度随机密码
4kaxd2$WV

# mkpasswd -d 3	 #生成指定数字位数的密码
ob4e}1NL2

为用户更改随机密码，当然如果想知道生成的密码需要配合shell来操作，这种方法适用于为很多用户修改随机密码。
# echo `mkpasswd -l 10` | passwd --stdin chenliang 

生成密码长度10，数字2个，小写3个，大写3个，特殊2个
# mkpasswd  -l 10 -d 2 -c 3 -C 3 -s 2  
W'.Ix5Kvd1
```

### more

```shell
# more 命令是一个基于vi编辑器文本过滤器，它以全屏幕的方式按页显示文本文件的内容，支持vi中的关键字定位操作。more名单中内置了若干快捷键，常用的有H（获得帮助信息），Enter（向下翻滚一行），空格（向下滚动一屏），Q（退出命令）。

该命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今己显示的该文件的百分比：--More--（XX%）可以用下列不同的方法对提示做出回答：
按Space键：显示文本的下一屏内容。
按Enier键：只显示文本的下一行内容。
按斜线符|：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。
按H键：显示帮助屏，该屏上有相关的帮助信息。
按B键：显示上一屏内容。
按Q键：退出rnore命令。

-<数字>：指定每屏显示的行数；
-d：显示“[press space to continue,'q' to quit.]”和“[Press 'h' for instructions]”；
-c：不进行滚屏操作。每次刷新这个屏幕；
-s：将多个空行压缩成一行显示；
-u：禁止下划线；
+<数字>：从指定数字的行开始显示。

# more -dc file	显示文件file的内容，但在显示之前先清屏，并且在屏幕的最下方显示完核的百分比。

# more -c -10 	file显示文件file的内容，每10行显示一次，而且在显示之前先清屏。
```

### mv

```shell
# mv 命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。source表示源文件或目录，target表示目标文件或目录。如果将一个文件移到一个已经存在的目标文件中，则目标文件的内容将被覆盖。
# mv 命令可以用来将源文件移至一个目标文件中，或将一组文件移至一个目标目录中。源文件被移至目标文件有两种不同的结果：
1、如果目标文件是到某一目录文件的路径，源文件会被移到此目录下，且文件名不变。
2、如果目标文件不是目录文件，则源文件名（只能有一个）会变为此目标文件名，并覆盖己存在的同名文件。如果源文件和目标文件在同一个目录下，mv的作用就是改文件名。当目标文件是目录文件时，源文件或目录参数可以有多个，则所有的源文件都会被移至目标文件中。所有移到该目录下的文件都将保留以前的文件名。
--backup=<备份模式>：若需覆盖文件，则覆盖前先行备份；
-b：当文件存在时，覆盖前，为其创建一个备份；
-f：若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录；
-i：交互式操作，覆盖前先行询问用户，如果源文件与目标文件或目标目录中的文件同名，则询问用户是否覆盖目标文件。用户输入”y”，表示将覆盖目标文件；输入”n”，表示取消对源文件的移动。这样可以避免误将文件覆盖。
--strip-trailing-slashes：删除源文件中的斜杠“/”；
-S<后缀>：为备份文件指定后缀，而不使用默认的后缀；
--target-directory=<目录>：指定源文件要移动到目标目录；
-u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。

# mv /usr/men/* .			将目录/usr/men中的所有文件移到当前目录中（用.表示）
```

### passwd

```shell
# passwd	命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。

-d：删除密码，仅有系统管理者才能使用；
-f：强制执行；
-k：设置只有在密码过期失效后，方能更新；
-l：锁住密码；
-s：列出密码的相关信息，仅有系统管理者才能使用；
-u：解开已上锁的帐号。

与用户、组账户信息相关的文件存放用户信息：
/etc/passwd
/etc/shadow


存放组信息：
/etc/group
/etc/gshadow


用户信息文件分析（每项用:隔开）:
例如：jack:X:503:504:::/home/jack/:/bin/bash
jack　　//用户名
X　　//口令、密码
503　　//用户id（0代表root、普通新建用户从500开始）
504　　//所在组
:　　//描述
/home/jack/　　//用户主目录
/bin/bash　　//用户缺省Shell


组信息文件分析:
例如：jack:$!$:???:13801:0:99999:7:*:*:
jack　　//组名
$!$　　//被加密的口令
13801　　//创建日期与今天相隔的天数
0　　//口令最短位数
99999　　//用户口令
7　　//到7天时提醒
*　　//禁用天数
*　　//过期天数


如果是普通用户执行passwd只能修改自己的密码。如果新建用户后，要为新用户创建密码，则用passwd用户名，注意要以root用户的权限来创建。

[root@localhost ~]# passwd linuxde    //更改或创建linuxde用户的密码；
Changing password for user linuxde.
New UNIX password:          //请输入新密码；
Retype new UNIX password:   //再输入一次；
passwd: all authentication tokens updated successfully. //成功；


普通用户如果想更改自己的密码，直接运行passwd即可，比如当前操作的用户是linuxde。

[linuxde@localhost ~]$ passwd
Changing password for user linuxde. //更改linuxde用户的密码；
(current) UNIX password:   //请输入当前密码；
New UNIX password:         //请输入新密码；
Retype new UNIX password:  //确认新密码；
passwd: all authentication tokens updated successfully. //更改成功；


比如我们让某个用户不能修改密码，可以用-l选项来锁定：

[root@localhost ~]# passwd -l linuxde    //锁定用户linuxde不能更改密码；
Locking password for user linuxde.
passwd: Success           //锁定成功；

[linuxde@localhost ~]# su linuxde   //通过su切换到linuxde用户；
[linuxde@localhost ~]$ passwd      //linuxde来更改密码；
Changing password for user linuxde.
Changing password for linuxde
(current) UNIX password:          //输入linuxde的当前密码；
passwd: Authentication token manipulation error     //失败，不能更改密码；


再来一例：

[root@localhost ~]# passwd -d linuxde  //清除linuxde用户密码；
Removing password for user linuxde.
passwd: Success                         //清除成功；

[root@localhost ~]# passwd -S linuxde    //查询linuxde用户密码状态；
Empty password.                         //空密码，也就是没有密码；

注意：当我们清除一个用户的密码时，登录时就无需密码，这一点要加以注意。
```

### poweroff

```shell
# poweroff           ### 关闭机器 
# poweroff --halt    ### 停止机器 
# poweroff --reboot  ### 重启机器 
```

### ps

```shell
# ps 命令用于报告当前系统的进程状态。可以搭配kill指令随时中断、删除不必要的程序。ps命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。
-a：显示所有终端机下执行的程序，除了阶段作业领导者之外。
a：显示现行终端机下的所有程序，包括其他用户的程序。
-A：显示所有程序。
-c：显示CLS和PRI栏位。
c：列出程序时，显示每个程序真正的指令名称，而不包含路径，选项或常驻服务的标示。
-C<指令名称>：指定执行指令的名称，并列出该指令的程序的状况。
-d：显示所有程序，但不包括阶段作业领导者的程序。
-e：此选项的效果和指定"A"选项相同。
e：列出程序时，显示每个程序所使用的环境变量。
-f：显示UID,PPIP,C与STIME栏位。
f：用ASCII字符显示树状结构，表达程序间的相互关系。
-g<群组名称>：此选项的效果和指定"-G"选项相同，当亦能使用阶段作业领导者的名称来指定。
g：显示现行终端机下的所有程序，包括群组领导者的程序。
-G<群组识别码>：列出属于该群组的程序的状况，也可使用群组名称来指定。
h：不显示标题列。
-H：显示树状结构，表示程序间的相互关系。
-j或j：采用工作控制的格式显示程序状况。
-l或l：采用详细的格式来显示程序状况。
L：列出栏位的相关信息。
-m或m：显示所有的执行绪。
n：以数字来表示USER和WCHAN栏位。
-N：显示所有的程序，除了执行ps指令终端机下的程序之外。
-p<程序识别码>：指定程序识别码，并列出该程序的状况。
p<程序识别码>：此选项的效果和指定"-p"选项相同，只在列表格式方面稍有差异。
r：只列出现行终端机正在执行中的程序。
-s<阶段作业>：指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的状况。
s：采用程序信号的格式显示程序状况。
S：列出程序时，包括已中断的子程序资料。
-t<终端机编号>：指定终端机编号，并列出属于该终端机的程序的状况。
t<终端机编号>：此选项的效果和指定"-t"选项相同，只在列表格式方面稍有差异。
-T：显示现行终端机下的所有程序。
-u<用户识别码>：此选项的效果和指定"-U"选项相同。
u：以用户为主的格式来显示程序状况。
-U<用户识别码>：列出属于该用户的程序的状况，也可使用用户名称来指定。
U<用户名称>：列出属于该用户的程序的状况。
v：采用虚拟内存的格式显示程序状况。
-V或V：显示版本信息。
-w或w：采用宽阔的格式来显示程序状况。　
x：显示所有程序，不以终端机来区分。
X：采用旧式的Linux i386登陆格式显示程序状况。
-y：配合选项"-l"使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位　。
-<程序识别码>：此选项的效果和指定"p"选项相同。
--cols<每列字符数>：设置每列的最大字符数。
--columns<每列字符数>：此选项的效果和指定"--cols"选项相同。
--cumulative：此选项的效果和指定"S"选项相同。
--deselect：此选项的效果和指定"-N"选项相同。
--forest：此选项的效果和指定"f"选项相同。
--headers：重复显示标题列。
--help：在线帮助。
--info：显示排错信息。
--lines<显示列数>：设置显示画面的列数。
--no-headers：此选项的效果和指定"h"选项相同，只在列表格式方面稍有差异。
--group<群组名称>：此选项的效果和指定"-G"选项相同。
--Group<群组识别码>：此选项的效果和指定"-G"选项相同。
--pid<程序识别码>：此选项的效果和指定"-p"选项相同。
--rows<显示列数>：此选项的效果和指定"--lines"选项相同。
--sid<阶段作业>：此选项的效果和指定"-s"选项相同。
--tty<终端机编号>：此选项的效果和指定"-t"选项相同。
--user<用户名称>：此选项的效果和指定"-U"选项相同。
--User<用户识别码>：此选项的效果和指定"-U"选项相同。
--version：此选项的效果和指定"-V"选项相同。
--widty<每列字符数>：此选项的效果和指定"-cols"选项相同。

# ps -aux		查看后台进程
```

### pwd

```shell
# pwd 命令以绝对路径的方式显示用户当前工作目录。命令将当前目录的全路径名称（从根目录）写入标准输出。全部目录使用/分隔。第一个/表示根目录，最后一个目录是当前目录。执行pwd命令可立刻得知您目前所在的工作目录的绝对路径名称。
--help：显示帮助信息；
--version：显示版本信息。
```

### reboot

```shell
# reboot           ### 重启机器 
# reboot --halt    ### 停止机器 
# reboot -p        ### 关闭机器 
```

### rm

```shell
# rm			目录删除命令
-d：直接把欲删除的目录的硬连接数据删除成0，删除该目录；
-f：强制删除文件或目录；
-i：删除已有文件或目录之前先询问用户；
-r或-R：递归处理，将指定目录下的所有文件与子目录一并处理；	# rm -r *
--preserve-root：不对根目录进行递归操作；
-v：显示指令的详细执行过程。
# rm -rf *		!!!千万不要来
```

### rmdir

```shell
# rmdir		删除空目录命令
-p或--parents：删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除；
--ignore-fail-on-non-empty：此选项使rmdir命令忽略由于删除非空目录时导致的错误信息；
-v或-verboes：显示命令的详细执行过程；
--help：显示命令的帮助信息；
--version：显示命令的版本信息。
```

### shutdown

```shell
# shutdown -h 10    ###计算机将在10分钟后关机，且会显示在登录用户的当前屏幕中
# shutdown -h now   ###立即关机
# shutdown -h 13:20 ###系统会在13:20关机
# shutdown -h +10   ### 10分钟后关机
# shutdown -r now   ### 立即重启   
# shutdown -r +10   ### 10分钟后重启 
# shutdown -c	    ### 取消即将进行的关机 
```

### ssh

```shell
# ssh 命令是openssh套件中的客户端连接工具，可以给予ssh加密协议实现安全的远程登录服务器。
-1：强制使用ssh协议版本1；
-2：强制使用ssh协议版本2；
-4：强制使用IPv4地址；
-6：强制使用IPv6地址；
-A：开启认证代理连接转发功能；
-a：关闭认证代理连接转发功能；
-b：使用本机指定地址作为对应连接的源ip地址；
-C：请求压缩所有数据；
-F：指定ssh指令的配置文件；
-f：后台执行ssh指令；
-g：允许远程主机连接主机的转发端口；
-i：指定身份文件；
-l：指定连接远程服务器登录用户名；
-N：不执行远程指令；
-o：指定配置选项；
-p：指定远程服务器上的端口；
-q：静默模式；
-X：开启X11转发功能；
-x：关闭X11转发功能；
-y：开启信任X11转发功能。

# ssh root@192.168.0.4	远程连接root@为用户（不写为当前主机用户身份登录）后边是IP地址
```

### su

```shell
# su	命令用于切换当前用户身份到其他用户身份，变更时须输入所要变更的用户帐号与密码。

-c<指令>或--command=<指令>：执行完指定的指令后，即恢复原来的身份；
-f或——fast：适用于csh与tsch，使shell不用去读取启动文件；
-l或——login：改变身份时，也同时变更工作目录，以及HOME,SHELL,USER,logname。此外，也会变更PATH变量；
-m,-p或--preserve-environment：变更身份时，不要变更环境变量；
-s<shell>或--shell=<shell>：指定要执行的shell；
--help：显示帮助；
--version；显示版本信息。


变更帐号为root并在执行ls指令后退出变回原使用者：
# su -c ls root

变更帐号为root并传入-f选项给新执行的shell：
# su root -f

变更帐号为test并改变工作目录至test的家目录：
# su -test
```

### sudo

```shell
# sudo	命令用来以其他身份来执行命令，预设的身份为root。在/etc/sudoers中设置了可执行sudo指令的用户。若其未经授权的用户企图使用sudo，则会发出警告的邮件给管理员。用户使用sudo时，必须先输入密码，之后有5分钟的有效期限，超过期限则必须重新输入密码。

-b：在后台执行指令；
-h：显示帮助；
-H：将HOME环境变量设为新身份的HOME环境变量；
-k：结束密码的有效期限，也就是下次再执行sudo时便需要输入密码；。
-l：列出目前用户可执行与无法执行的指令；
-p：改变询问密码的提示符号；
-s<shell>：执行指定的shell；
-u<用户>：以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份；
-v：延长密码有效期限5分钟；
-V ：显示版本信息。

配置sudo必须通过编辑/etc/sudoers文件，而且只有超级用户才可以修改它，还必须使用visudo编辑。之所以使用visudo有两个原因，一是它能够防止两个用户同时修改它；二是它也能进行有限的语法检查。所以，即使只有你一个超级用户，你也最好用visudo来检查一下语法。

visudo默认的是在vi里打开配置文件，用vi来修改文件。我们可以在编译时修改这个默认项。visudo不会擅自保存带有语法错误的配置文件，它会提示你出现的问题，并询问该如何处理，就像：

>>> sudoers file: syntax error, line 22 <<
此时我们有三种选择：键入“e”是重新编辑，键入“x”是不保存退出，键入“Q”是退出并保存。如果真选择Q，那么sudo将不会再运行，直到错误被纠正。

现在，我们一起来看一下神秘的配置文件，学一下如何编写它。让我们从一个简单的例子开始：让用户Foobar可以通过sudo执行所有root可执行的命令。以root身份用visudo打开配置文件，可以看到类似下面几行：

# Runas alias specification
# User privilege specificationroot    ALL=(ALL)ALL
我们一看就明白个差不多了，root有所有权限，只要仿照现有root的例子就行，我们在下面加一行（最好用tab作为空白）：

foobar ALL=(ALL)    ALL
保存退出后，切换到foobar用户，我们用它的身份执行命令：

[foobar@localhost ~]$ ls /root
ls: /root: 权限不够

[foobar@localhost ~]$ sudo ls /root
PassWord:
anaconda-ks.cfg Desktop install.log install.log.syslog
好了，我们限制一下foobar的权利，不让他为所欲为。比如我们只想让他像root那样使用ls和ifconfig，把那一行改为：

foobar localhost=    /sbin/ifconfig,   /bin/ls
再来执行命令：

[foobar@localhost ~]$ sudo head -5 /etc/shadow
Password:
Sorry, user foobar is not allowed to execute '/usr/bin/head -5 /etc/shadow' as root on localhost.localdomain.

[foobar@localhost ~]$ sudo /sbin/ifconfigeth0      Linkencap:Ethernet HWaddr 00:14:85:EC:E9:9B...
现在让我们来看一下那三个ALL到底是什么意思。第一个ALL是指网络中的主机，我们后面把它改成了主机名，它指明foobar可以在此主机上执行后面的命令。第二个括号里的ALL是指目标用户，也就是以谁的身份去执行命令。最后一个ALL当然就是指命令名了。例如，我们想让foobar用户在linux主机上以jimmy或rene的身份执行kill命令，这样编写配置文件：

foobar    linux=(jimmy,rene)    /bin/kill
但这还有个问题，foobar到底以jimmy还是rene的身份执行？这时我们应该想到了sudo -u了，它正是用在这种时候。 foobar可以使用sudo -u jimmy kill PID或者sudo -u rene kill PID，但这样挺麻烦，其实我们可以不必每次加-u，把rene或jimmy设为默认的目标用户即可。再在上面加一行：

Defaults:foobar    runas_default=rene
Defaults后面如果有冒号，是对后面用户的默认，如果没有，则是对所有用户的默认。就像配置文件中自带的一行：

Defaults    env_reset
另一个问题是，很多时候，我们本来就登录了，每次使用sudo还要输入密码就显得烦琐了。我们可不可以不再输入密码呢？当然可以，我们这样修改配置文件：

foobar localhost=NOPASSWD:     /bin/cat, /bin/ls
再来sudo一下：

[foobar@localhost ~]$ sudo ls /rootanaconda-ks.cfg Desktop install.log
install.log.syslog
当然，你也可以说“某些命令用户foobar不可以运行”，通过使用!操作符，但这不是一个好主意。因为，用!操作符来从ALL中“剔出”一些命令一般是没什么效果的，一个用户完全可以把那个命令拷贝到别的地方，换一个名字后再来运行。

日志与安全

sudo为安全考虑得很周到，不仅可以记录日志，还能在有必要时向系统管理员报告。但是，sudo的日志功能不是自动的，必须由管理员开启。这样来做：

touch /var/log/sudo
vi /etc/syslog.conf
在syslog.conf最后面加一行（必须用tab分割开）并保存：

local2.debug                    /var/log/sudo
重启日志守候进程，

ps aux grep syslogd
把得到的syslogd进程的PID（输出的第二列是PID）填入下面：

kill –HUP PID
这样，sudo就可以写日志了：

[foobar@localhost ~]$ sudo ls /rootanaconda-ks.cfg
Desktop install.log
install.log.syslog
$cat /var/log/sudoJul 28 22:52:54 localhost sudo:   foobar :
TTY=pts/1 ; pwd=/home/foobar ; USER=root ; command=/bin/ls /root
不过，有一个小小的“缺陷”，sudo记录日志并不是很忠实：

[foobar@localhost ~]$ sudo cat /etc/shadow > /dev/null
cat /var/log/sudo...Jul 28 23:10:24 localhost sudo:   foobar : TTY=pts/1 ;
PWD=/home/foobar ; USER=root ; COMMAND=/bin/cat /etc/shadow
重定向没有被记录在案！为什么？因为在命令运行之前，shell把重定向的工作做完了，sudo根本就没看到重定向。这也有个好处，下面的手段不会得逞：

[foobar@localhost ~]$ sudo ls /root > /etc/shadowbash: /etc/shadow: 权限不够
sudo 有自己的方式来保护安全。以root的身份执行sudo-V，查看一下sudo的设置。因为考虑到安全问题，一部分环境变量并没有传递给sudo后面的命令，或者被检查后再传递的，比如：PATH，HOME，SHELL等。当然，你也可以通过sudoers来配置这些环境变量。
```

### sync

```shell
# sync命令用于强制被改变的内容立刻写入磁盘，更新超块信息。

在Linux/Unix系统中，在文件或数据处理过程中一般先放到内存缓冲区中，等到适当的时候再写入磁盘，以提高系统的运行效率。sync命令则可用来强制将内存缓冲区中的数据立即写入磁盘中。用户通常不需执行sync命令，系统会自动执行update或bdflush操作，将缓冲区的数据写 入磁盘。只有在update或bdflush无法执行或用户需要非正常关机时，才需手动执行sync命令。

# sync	把当前内存中的数据写入磁盘
```

### tac

```shell
# tac 命令用于将文件已行为单位的反序输出，即第一行最后显示，最后一行先显示。
-a或——append：将内容追加到文件的末尾；
-i或——ignore-interrupts：忽略中断信号。
```

### tail

```shell
# tail 命令用于输入文件中的尾部内容。tail命令默认在屏幕上显示指定文件的末尾10行。如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题。如果没有指定文件或者文件名为“-”，则读取标准输入。
注意：如果表示字节或行数的N值之前有一个”+”号，则从文件开头的第N项开始显示，而不是显示文件的最后N项。N值后面可以有后缀：b表示512，k表示1024，m表示1 048576(1M)。

--retry：即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与选项“——follow=name”连用；
-c<N>或——bytes=<N>：输出文件尾部的N（N为整数）个字节内容；
-f<name/descriptor>或；--follow<nameldescript>：显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效；
-F：与选项“-follow=name”和“--retry"连用时功能相同；
-n<N>或——line=<N>：输出文件的尾部N（N位数字）行内容。
--pid=<进程号>：与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令；
-q或——quiet或——silent：当有多个文件参数时，不输出各个文件名；
-s<秒数>或——sleep-interal=<秒数>：与“-f”选项连用，指定监视文件变化时间隔的秒数；
-v或——verbose：当有多个文件参数时，总是输出各个文件名；
--help：显示指令的帮助信息；
--version：显示指令的版本信息。

# tail file （显示文件file的最后10行）
# tail +20 file （显示文件file的内容，从第20行至文件末尾）
# tail -c 10 file （显示文件file的最后10个字符）
```

### tar

```shell
Linux tar（英文全拼：tape archive ）命令用于备份文件。
tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。

-A或--catenate 新增文件到已存在的备份文件。
-b<区块数目>或--blocking-factor=<区块数目> 设置每笔记录的区块数目，每个区块大小为12Bytes。
-B或--read-full-records 读取数据时重设区块大小。
-c或--create 建立新的备份文件。
-C<目的目录>或--directory=<目的目录> 切换到指定的目录。
-d或--diff或--compare 对比备份文件内和文件系统上的文件的差异。
-f<备份文件>或--file=<备份文件> 指定备份文件。
-F<Script文件>或--info-script=<Script文件> 每次更换磁带时，就执行指定的Script文件。
-g或--listed-incremental 处理GNU格式的大量备份。
-G或--incremental 处理旧的GNU格式的大量备份。
-h或--dereference 不建立符号连接，直接复制该连接所指向的原始文件。
-i或--ignore-zeros 忽略备份文件中的0 Byte区块，也就是EOF。
-k或--keep-old-files 解开备份文件时，不覆盖已有的文件。
-K<文件>或--starting-file=<文件> 从指定的文件开始还原。
-l或--one-file-system 复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。
-L<媒体容量>或-tape-length=<媒体容量> 设置存放每体的容量，单位以1024 Bytes计算。
-m或--modification-time 还原文件时，不变更文件的更改时间。
-M或--multi-volume 在建立，还原备份文件或列出其中的内容时，采用多卷册模式。
-N<日期格式>或--newer=<日期时间> 只将较指定日期更新的文件保存到备份文件里。
-o或--old-archive或--portability 将资料写入备份文件时使用V7格式。
-O或--stdout 把从备份文件里还原的文件输出到标准输出设备。
-p或--same-permissions 用原来的文件权限还原文件。
-P或--absolute-names 文件名使用绝对名称，不移除文件名称前的"/"号。
-r或--append 新增文件到已存在的备份文件的结尾部分。
-R或--block-number 列出每个信息在备份文件中的区块编号。
-s或--same-order 还原文件的顺序和备份文件内的存放顺序相同。
-S或--sparse 倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。
-t或--list 列出备份文件的内容。
-T<范本文件>或--files-from=<范本文件> 指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。
-u或--update 仅置换较备份文件内的文件更新的文件。
-U或--unlink-first 解开压缩文件还原文件之前，先解除文件的连接。
-v或--verbose 显示指令执行过程。
-V<卷册名称>或--label=<卷册名称> 建立使用指定的卷册名称的备份文件。
-w或--interactive 遭遇问题时先询问用户。
-W或--verify 写入备份文件后，确认文件正确无误。
-x或--extract或--get 从备份文件中还原文件。
-X<范本文件>或--exclude-from=<范本文件> 指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。
-z或--gzip或--ungzip 通过gzip指令处理备份文件。
-Z或--compress或--uncompress 通过compress指令处理备份文件。
-<设备编号><存储密度> 设置备份用的外围设备编号及存放数据的密度。
--after-date=<日期时间> 此参数的效果和指定"-N"参数相同。
--atime-preserve 不变更文件的存取时间。
--backup=<备份方式>或--backup 移除文件前先进行备份。
--checkpoint 读取备份文件时列出目录名称。
--concatenate 此参数的效果和指定"-A"参数相同。
--confirmation 此参数的效果和指定"-w"参数相同。
--delete 从备份文件中删除指定的文件。
--exclude=<范本样式> 排除符合范本样式的文件。
--group=<群组名称> 把加入设备文件中的文件的所属群组设成指定的群组。
--help 在线帮助。
--ignore-failed-read 忽略数据读取错误，不中断程序的执行。
--new-volume-script=<Script文件> 此参数的效果和指定"-F"参数相同。
--newer-mtime 只保存更改过的文件。
--no-recursion 不做递归处理，也就是指定目录下的所有文件及子目录不予处理。
--null 从null设备读取文件名称。
--numeric-owner 以用户识别码及群组识别码取代用户名称和群组名称。
--owner=<用户名称> 把加入备份文件中的文件的拥有者设成指定的用户。
--posix 将数据写入备份文件时使用POSIX格式。
--preserve 此参数的效果和指定"-ps"参数相同。
--preserve-order 此参数的效果和指定"-A"参数相同。
--preserve-permissions 此参数的效果和指定"-p"参数相同。
--record-size=<区块数目> 此参数的效果和指定"-b"参数相同。
--recursive-unlink 解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。
--remove-files 文件加入备份文件后，就将其删除。
--rsh-command=<执行指令> 设置要在远端主机上执行的指令，以取代rsh指令。
--same-owner 尝试以相同的文件拥有者还原文件。
--suffix=<备份字尾字符串> 移除文件前先行备份。
--totals 备份文件建立后，列出文件大小。
--use-compress-program=<执行指令> 通过指定的指令处理备份文件。
--version 显示版本信息。
--volno-file=<编号文件> 使用指定文件内的编号取代预设的卷册编号。


压缩文件 非打包
# touch a.c       
# tar -czvf test.tar.gz a.c   //压缩 a.c文件为test.tar.gz
a.c

列出压缩文件内容
# tar -tzvf test.tar.gz 
-rw-r--r-- root/root     0 2010-05-24 16:51:59 a.c

解压文件
# tar -xzvf test.tar.gz 
a.c
```

### umask

```shell
# umask 命令用来设置限制新建文件权限的掩码。当新文件被创建时，其最初的权限由文件创建掩码决定。用户每次注册进入系统时，umask命令都被执行， 并自动设置掩码mode来限制新文件的权限。用户可以通过再次执行umask命令来改变默认值，新的权限将会把旧的覆盖掉。
-p：输出的权限掩码可直接作为指令来执行；
-S：以符号方式输出权限掩码。

利用umask命令可以指定哪些权限将在新文件的默认权限中被删除。例如，可以使用下面的命令创建掩码，使得组用户的写权限，其他用户的读、写和执行权限都被取消：
# umask u=, g=w, o=rwx
执行该命令以后，对于下面创建的新文件，其文件主的权限未做任何改变，而组用户没有写权限，其他用户的所有权限都被取消。

	应注意：操作符“=”在umask命令和chmod命令中的作用恰恰相反。在chmod命令中，利用它来设置指定的权限，而其余权限则被删除；但是在umask命令中，它将在原有权限的基础上删除指定的权限。不能直接利用umask命令创建一个可执行的文件，用户只能在其后利用chmod命令使它具有执行权限。假设执行了命令umask u=, g=w, o=rwx，虽然在命令行中，没有删去文件主和组用户的执行权限，但默认的文件权限还是640（即 rw-r-----），而不是750(rwxr-x---）。但是，如果创建的是目录或者通过编译程序创建的一个可执行文件，将不受此限制。在这种情况 下，会设置文件的执行权限。
	也可以使用八进制数值来设置mode。由于在umask中所指定的权限是要从文件中删除的，所以，如果该文件原来的初始化权限是777，那么执行命令umask 022以后，该文件的权限将变为755：如果该文件原来的初始化权限是666，那么该文件的权限将变为644。

可以使用下面的命令检查新创建文件的默认权限：
# umask -s
选项-s表示以字符形式显示当前的掩码。如果直接输入umask命令，不带任何参数，那么将以八进制形式显示当前的掩码。系统默认的掩码是0022。
```

### userdel

```shell
# userdel	命令用于删除给定的用户，以及与用户相关的文件。若不加选项，则仅删除用户帐号，而不删除相关文件。

-f：强制删除用户，即使用户当前已登录；
-r：删除用户的同时，删除与用户相关的所有文件。

userdel命令很简单，比如我们现在有个用户linuxde，其家目录位于/var目录中，现在我们来删除这个用户：

# userdel linuxde       //删除用户linuxde，但不删除其家目录及文件；
# userdel -r linuxde    //删除用户linuxde，其家目录及文件一并删除；
请不要轻易用-r选项；他会删除用户的同时删除用户所有的文件和目录，切记如果用户目录下有重要的文件，在删除前请备份。

其实也有最简单的办法，但这种办法有点不安全，也就是直接在/etc/passwd中删除您想要删除用户的记录；但最好不要这样做，/etc/passwd是极为重要的文件，可能您一不小心会操作失误。
```

### whereis

```shell
# whereis命令用来定位指令的二进制程序、源代码文件和man手册页等相关文件的路径。
# whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。
-b：只查找二进制文件；
-B<目录>：只在设置的目录下查找二进制文件；
-f：不显示文件名前的路径名称；
-m：只查找说明文件；
-M<目录>：只在设置的目录下查找说明文件；
-s：只查找原始代码文件；
-S<目录>只在设置的目录下查找原始代码文件；
-u：查找不包含指定类型的文件。

将相关的文件都查找出来
# whereis tomcat
tomcat:
# whereis svn
svn: /usr/bin/svn /usr/local/svn /usr/share/man/man1/svn.1.gz
说明：tomcat没安装，找不出来，svn安装找出了很多相关文件

只将二进制文件查找出来 
# whereis -b svn
svn: /usr/bin/svn /usr/local/svn
# whereis -m svn
svn: /usr/share/man/man1/svn.1.gz
# whereis -s svn
svn:
```

### which

```shell
# which命令用于查找并显示给定命令的绝对路径，环境变量PATH中保存了查找命令时需要遍历的目录。
# which指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。
-n<文件名长度>：制定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名；
-p<文件名长度>：与-n参数相同，但此处的<文件名长度>包含了文件的路径；
-w：指定输出时栏位的宽度；
-V：显示版本信息。
查找文件、显示命令路径：
# which pwd
/bin/pwd
#  which adduser
/usr/sbin/adduser
```

### who

```shell
# who 命令是显示目前登录系统的用户信息。执行who命令可得知目前有那些用户登入系统，单独执行who命令会列出登入帐号，使用的终端机，登入时间以及从何处登入或正在使用哪个X显示器。
-H或--heading：显示各栏位的标题信息列；
-i或-u或--idle：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成"."号，如果该用户已超过24小时没有任何动作，则标示出"old"字符串；
-m：此参数的效果和指定"am i"字符串相同；
-q或--count：只显示登入系统的帐号名称和总人数；
-s：此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题；
-w或-T或--mesg或--message或--writable：显示用户的信息状态栏；
--help：在线帮助；
--version：显示版本信息。

# who		查看在线用户
# whoami	查看用户
# who am i 	显示用户和用户详细信息
```

## 终端快捷键：

Ctrl+c	结束（终止）当前命令

Tab		实现自动补全功能

Ctrl+D	退出当前终端，同exit命令

Ctrl+Z	暂停当前进程，fg可以恢复进程

Ctrl+L	清屏

Ctrl+A	让光标移动到命令行首

Ctrl+E	让光标移动到命令行尾

## Linux目录结构：

/bin :  bin是Binary的缩写，该目录下存放的是最常用的命令。

/boot :  该目录下存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。

/dev :  dev是Device（设备）的缩写。该目录下存放的是Linux的外部设备。在Linux中，访问设备的方式和访问文件的方式是相同的。

/etc :  该目录下存放的是所有系统管理所需要的配置文件和子目录。

/home :  这是用户的家目录。在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。

/lib和/lib64 :  这两个目录下存放的是系统最基本的动态链接共享库，其作用类似于windows里的DLL文件，几乎所有的应用程序都需要用到这些共享库。其中/lib64为64位的软件包的库文件所在目录。

/media :  系统会自动识别一些设备（如U盘、光驱等），当识别后，Linux会把识别的设备挂载到该目录下。

/mnt :  系统提供该目录是为了让用户临时挂在别的文件系统。我们可以将光驱挂载到/mnt/上，然后进入该目录查看光驱里的内容。

/opt :  这是给主机额外安装软件所设置的文件目录，该目录默认为空。比如，你要安装一个Oracle数据库，可以放到该目录下。

/proc :  该目录是一个虚拟目录，是系统内存的映射，可以直接访问它来获取系统信息。该目录的内容在内存里，我们可以直接修改里面的某些文件。比如可以通过下面的命令来屏蔽主机的ping命令，使其他人无法ping你的机子。在日常工作中，你会经常用到类似的方法：

```shell
# echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all
```

/root :  该目录是系统管理员的用户家目录。

/rum :  这个目录其实和/var/rum是同一个目录，这里面存放的是一些服务的pid。一个服务启动完后，是有一个pid文件的。

/sbin :  s就是Super User的意思，该目录存放的是系统管理员使用的系统管理程序。

/srv :  该目录存放的是一些服务启动之后需要提取的数据。

/sys :  该目录下存放的是与硬件驱动程序相关的信息。

/tmp :  该目录用来存放一些临时文件。

/usr :  这是一个非常重要的目录，类似于windows下的Program Files目录，用户的很多应用程序和文件都存放在该目录下。

/usr/bin :  该目录存放的是系统用户使用的应用程序。

/usr/sbin :  该目录存放的是超级用户使用的比较高级的管理程序和系统守护程序。

/usr/src :  该目录是内核源代码默认的放置目录。

/var :  该目录存放的是不断扩充且经常修改的目录，包括各种日志文件或者pid文件，其中刚刚提到的/var/run就是在这个目录下面。

```
/etc目录下是系统的配置文件，如果更改了该目录下的某个文件，可能会导致系统无法正常启动。

/bin、/sbin、/usr/bin和/usr/sbin目录是系统预设的执行文件的放置目录，其中/bin和/usr/bin目录下是供系统用户使用的指令（除root外的通用账户），而/sbin和/usr/sbin目录下则是供root使用的指令。比如，ls指令就存放在/bin/目录下。

/var也是一个非常重要的目录，在系统上运行各个程序时所产生的日志都被记录在该目录下（即/var/log目录中）。另外mail指令的预设也放置在这里
```

## Linux文件属性：

用ls -l命令查看当前目录下的文件时，共显示了9列内容（用空格划分）

### 第一列：

包含该文件的类型、所有者、所属组以及其他用户对该文件的权限。第一列共11位，其中第一位用来描述该文件的类型。

- d表示该文件为目录

- -表示该文件为普通文件

- l表示该文件为链接文件（link file）

```shell
# ls -l /etc/rc.local
lrwxrwxrwx. 1 root root 2月 13 22:32 /etc/rc.local -> rc.local

上例中，第一列第一位是l，表示该文件为链接文件。
```

- b表示该文件为块设备，比如/dev/sda就是这样的文件，磁盘分区文件就是这种类型。

- c表示该文件为串行端口设备文件（又称字符设备文件），比如键盘、鼠标、打印机、tty终端等都是这样的文件。

- s表示该文件为套接字文件（socket），用于进程之间的通信。

- 文件类型后边的9位，每3位一组，上例中（rc.local)均为rwx这三个参数的组合。其中，r代表可读，w代表可写，x代表可执行。前3位为所有者(user)的权限，中间三位为所属组(group)的权限，最后3位为其他非本群组用户(others)的权限。 

 例： 

假设一个文件的属性为-rwxr-xr--,它代表的意思是，该文件为普通文件，文件拥有者可读、可写且可执行，文件所属组对其可读、不可写但可执行，其他用户对其只可读。对于一个目录来讲，打开这个目录即为执行这个目录，所以任何一个日录必须要有x权限才能打开并查看该目录下的内容。例如，一个目录的属性为drwxr--r--，其所有者为root,那么除root之外的其他用户是不能打开这个目录的。

关于前面提到第1列最后1位的“.”，要特别说明- 下。老版本CentOS 5是没有这个点的，这主要是因为新版本的ls添加了SELinux或者acl的属性。如果文件或者目录使用了SELinuxcontext的属性，这里会是一个点 “.”;如果设置了acl的属性，这里会是一个加号“+”。

### 第二列：

表示该文件占用的节点（inode)，如果是目录，那这个数值与该目录下的子目录数量有关

### 第三列：

表示该文件的所有者

### 第四列：

表示该文件的所属组

### 第五列：

表示该文件的大小

### 第六列：第七列：第八列：

表示该文件最后一次被修改的时间(mtime)，依次为月份、日期以及时间

### 第九列：

表示文件名

## 认识/etc/passwd和/etc/shadow

### /etc/passwd

/etc/passwd由：分割成7个字段，每个字段的具体含义如下所示

- 第一个字段为用户名（如弟1行中的root就是用户名），它是代表用户账户的字符串。用户名中的字符可以是大小写字符、数字、减号（不能出现在首位）、点或下划线，其他字符不合法。虽然用户名中可以出现点，但不建议用，尤其是首位。另外减号也不建议用，容易造成混洗。
- 第2个字段存放的是账号的口令。这里为什么是X呢？早期的Unix系统口令确实存放在这，但基于安全因素，后来就将其存放到/etc/shadow中去了，这里只用一个x替代。
- 第3个字段为一个数字，这个数字代表用户标识号，也成为uid。系统就是通过这个数字识别用户身份的。这里的0就是root，也就是说我们可以通过修改test用户的uid为0，那么系统会认为root和test为同一个账户。uid的取值范围是0~65535（但实际上已经可以支持到4294967294)，0是超级用户(root)的标识号，centos7的普通用户标识号从1000开始。如果我们自定义建立一个普通用户，你会看到该账户的标识号是大于或等于1000的。
- 第4个字段也是数字，表示组标识号，也称gid。这个字段对应着/etc/group中的一条记录，其实/etc/group和/etc/passwd基本类似。
- 第5个字段为注释说明，没有实际意义。通常记录一些该用户的属性，例如：姓名、电话、地址等。我们可以使用chfn命令来更改信息。
- 第6个字段为用户的家目录，当用户登陆时，就处在这个目录下。root的家目录是/root，普通用户的家目录则为/home/userneme,用户家目录是可以自定义的。比如建立一个普通用户test1，要想让test1的家目录在/data下，只要将/etc/passwd文件中对用该用户那行中的本字段修改为/data即可。
- 最后一个字段为用户的shell。用户登录后，要启动一个进程，用来将用户下达的指令传给内核，这就是shell。Linux的shell有sh、csh、ksh、tcsh、bash等多种，而Red Hat/Centos的shell就是bash。查看/etc/passwd文件，该字段中除了/bin/bash，还有很多/sbin/nologin,默认是/bin/bash。



### /etc/shadow

- 第一个字符段为用户名，与/etc/passwd对应。
- 第二个字符段为用户密码，是该账号的真正密码。这个密码已经加密，但是有些黑客还是能够解密的。所以，将该文件属性设置为000，但root账户是可以访问或更改的。
- 第三个字段为上次更改密码的日期，这个数字以1970年1月1日和上次更改密码的日期为基准计算而来。例如，上次更改密码的日期为2012年1月1日，则这个值就是365*（2012-1970）+（2012-1970）/4+1=15341.如果是闰年，则有366天。
- 第四个字段为要过多少天才可以更改密码，默认是0，不受限制。
- 第五个字段为密码多少天后到期，即在多少天内必须更改密码。例如，这里设置成30，则30天内必须更改一次密码；否者，将不能登录系统。默认是99999，可以理解为永远不需要改。
- 第六个字段为密码到期前的警告期限。若这个值设置成，则表示当7天后密码过期时，系统就会发出警告，提醒用户他的密码将在7天后过期。
- 第七个字段为账号失效期限。如果这个设置为3，则表示密码已经到期，然而用户并没有在到期前修改密码，那么再过3天，这个账号便失效，即锁定。
- 第八个字段为账号的生命周期。跟第三个字段一样，这个周期是按距离1970年1月1号多少天算的。它表示的含义是，账号在这个日期前可以使用，到期后账号作废。
- 最后一个字段作为保留用的，没有什么意义。

